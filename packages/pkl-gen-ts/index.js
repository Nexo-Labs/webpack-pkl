const { getPklPath, getPklPathSync } = require('@nexo-labs/pkl-cli');
const { spawn, spawnSync } = require('child_process');
const fs = require('fs');
const path = require('path');

class PklTypeGenerator {
  constructor(options = {}) {
    this.options = {
      outputDir: options.outputDir || './generated',
      generateClasses: options.generateClasses !== false,
      generateInterfaces: options.generateInterfaces !== false,
      ...options
    };
  }

  async generate(filePath, outputPath) {
    const absoluteFilePath = path.resolve(filePath);
    
    if (!fs.existsSync(absoluteFilePath)) {
      throw new Error(`File not found: ${absoluteFilePath}`);
    }

    // Get the schema information from Pkl
    const schema = await this.extractSchema(absoluteFilePath);
    
    // Generate TypeScript code
    const tsCode = this.generateTypeScript(schema, path.basename(filePath, '.pkl'));
    
    // Write to output file
    if (outputPath) {
      const outputDir = path.dirname(outputPath);
      if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
      }
      fs.writeFileSync(outputPath, tsCode);
    }
    
    return tsCode;
  }

  async extractSchema(filePath) {
    const pklPath = await getPklPath();
    
    return new Promise((resolve, reject) => {
      const isJavaCommand = typeof pklPath === 'string' && pklPath.startsWith('java');
      let command, commandArgs;
      
      if (isJavaCommand) {
        [command, ...commandArgs] = pklPath.split(' ');
        commandArgs = [...commandArgs, 'eval', '-f', 'json', '--schema', filePath];
      } else {
        command = pklPath;
        commandArgs = ['eval', '-f', 'json', filePath];
      }

      const pkl = spawn(command, commandArgs);

      let stdout = '';
      let stderr = '';

      pkl.stdout.on('data', (data) => {
        stdout += data;
      });

      pkl.stderr.on('data', (data) => {
        stderr += data;
      });

      pkl.on('close', (code) => {
        if (code === 0) {
          try {
            // Since we can't use --schema flag easily, we'll analyze the output structure
            const data = JSON.parse(stdout);
            const schema = this.analyzeStructure(data);
            resolve(schema);
          } catch (error) {
            reject(new Error(`Error parsing schema: ${error.message}`));
          }
        } else {
          reject(new Error(`Pkl schema extraction failed: ${stderr}`));
        }
      });
    });
  }

  analyzeStructure(data, name = 'Root') {
    const structure = {
      name,
      type: 'object',
      properties: {},
      required: []
    };

    if (data === null || data === undefined) {
      return { name, type: 'null' };
    }

    if (typeof data === 'string') {
      return { name, type: 'string' };
    }

    if (typeof data === 'number') {
      return { name, type: Number.isInteger(data) ? 'number' : 'number' };
    }

    if (typeof data === 'boolean') {
      return { name, type: 'boolean' };
    }

    if (Array.isArray(data)) {
      const itemType = data.length > 0 ? this.analyzeStructure(data[0], 'Item') : { type: 'unknown' };
      return {
        name,
        type: 'array',
        items: itemType
      };
    }

    if (typeof data === 'object') {
      for (const [key, value] of Object.entries(data)) {
        structure.properties[key] = this.analyzeStructure(value, this.capitalize(key));
        structure.required.push(key);
      }
    }

    return structure;
  }

  generateTypeScript(schema, moduleName) {
    const interfaces = [];
    const types = [];
    
    // Generate main interface
    const mainInterface = this.generateInterface(schema, moduleName);
    interfaces.push(mainInterface);
    
    // Generate nested interfaces
    const nestedInterfaces = this.generateNestedInterfaces(schema, new Set());
    interfaces.push(...nestedInterfaces);
    
    const header = `// Generated by pkl-gen-ts
// Do not edit this file manually

`;
    
    return header + interfaces.join('\n\n') + '\n';
  }

  generateInterface(schema, name) {
    if (schema.type !== 'object') {
      return this.generateTypeAlias(schema, name);
    }

    const properties = Object.entries(schema.properties || {})
      .map(([key, propSchema]) => {
        const isOptional = !schema.required?.includes(key);
        const propType = this.getTypeScriptType(propSchema);
        return `  ${key}${isOptional ? '?' : ''}: ${propType};`;
      })
      .join('\n');

    return `export interface ${name} {
${properties}
}`;
  }

  generateTypeAlias(schema, name) {
    const type = this.getTypeScriptType(schema);
    return `export type ${name} = ${type};`;
  }

  generateNestedInterfaces(schema, visited) {
    const interfaces = [];
    
    if (schema.type === 'object' && schema.properties) {
      for (const [key, propSchema] of Object.entries(schema.properties)) {
        if (propSchema.type === 'object' && !visited.has(propSchema.name)) {
          visited.add(propSchema.name);
          interfaces.push(this.generateInterface(propSchema, propSchema.name));
          interfaces.push(...this.generateNestedInterfaces(propSchema, visited));
        } else if (propSchema.type === 'array' && propSchema.items?.type === 'object') {
          const itemName = propSchema.items.name;
          if (!visited.has(itemName)) {
            visited.add(itemName);
            interfaces.push(this.generateInterface(propSchema.items, itemName));
            interfaces.push(...this.generateNestedInterfaces(propSchema.items, visited));
          }
        }
      }
    }
    
    return interfaces;
  }

  getTypeScriptType(schema) {
    switch (schema.type) {
      case 'string':
        return 'string';
      case 'number':
        return 'number';
      case 'boolean':
        return 'boolean';
      case 'null':
        return 'null';
      case 'array':
        const itemType = this.getTypeScriptType(schema.items);
        return `${itemType}[]`;
      case 'object':
        return schema.name || 'Record<string, unknown>';
      default:
        return 'unknown';
    }
  }

  capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
}

const generate = async (filePath, options = {}) => {
  const generator = new PklTypeGenerator(options);
  return await generator.generate(filePath, options.outputPath);
};

const generateSync = (filePath, options = {}) => {
  // For now, we'll throw an error for sync generation as it's complex
  throw new Error('Synchronous TypeScript generation is not yet supported. Please use the async generate function.');
};

module.exports = { 
  generate,
  generateSync,
  PklTypeGenerator
};
